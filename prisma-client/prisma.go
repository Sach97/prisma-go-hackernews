// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.
package prisma

import (
	"context"
	"fmt"
	"reflect"
	"strconv"

	"github.com/machinebox/graphql"
	"github.com/mitchellh/mapstructure"
)

// ID docs
type ID struct{}

// Queries

// Exists

// Link exists docs
func (exists *Exists) Link(params *LinkWhereUniqueInput) bool {
	client := Client{
		Endpoint: (map[bool]string{true: exists.Endpoint, false: "http://localhost:4466"})[exists.Endpoint != ""],
		Debug:    exists.Debug,
	}
	data, err := client.Link(
		params,
	).Exec()
	if err != nil {
		if client.Debug {
			fmt.Println("Error Exists", err)
		}
		return false
	}
	if isZeroOfUnderlyingType(data) {
		return false
	}
	return true
}

// LinkParams docs
type LinkParams struct {
	Where *LinkWhereUniqueInput `json:"where"`
}

// Link docs - generated while printing operation - query
func (client Client) Link(params *LinkWhereUniqueInput) *LinkExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "LinkWhereUniqueInput!",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "link",
		Field: GraphQLField{
			Name:       "link",
			TypeName:   "Link",
			TypeFields: []string{"id", "createdAt", "description", "url"},
		},
		Operation: "query",
		Args:      args,
	})

	return &LinkExec{
		client: client,
		stack:  stack,
	}
}

// LinksParams docs
type LinksParams struct {
	Where   *LinkWhereInput   `json:"where,omitempty"`
	OrderBy *LinkOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

// Links docs - generated while printing operation - query
func (client Client) Links(params *LinksParams) *LinkExecArray {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil && params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "LinkWhereInput",
			Value:    *params.Where,
		})
	}
	if params != nil && params.OrderBy != nil {
		args = append(args, GraphQLArg{
			Name:     "orderBy",
			Key:      "orderBy",
			TypeName: "LinkOrderByInput",
			Value:    *params.OrderBy,
		})
	}
	if params != nil && params.Skip != nil {
		args = append(args, GraphQLArg{
			Name:     "skip",
			Key:      "skip",
			TypeName: "Int",
			Value:    *params.Skip,
		})
	}
	if params != nil && params.After != nil {
		args = append(args, GraphQLArg{
			Name:     "after",
			Key:      "after",
			TypeName: "String",
			Value:    *params.After,
		})
	}
	if params != nil && params.Before != nil {
		args = append(args, GraphQLArg{
			Name:     "before",
			Key:      "before",
			TypeName: "String",
			Value:    *params.Before,
		})
	}
	if params != nil && params.First != nil {
		args = append(args, GraphQLArg{
			Name:     "first",
			Key:      "first",
			TypeName: "Int",
			Value:    *params.First,
		})
	}
	if params != nil && params.Last != nil {
		args = append(args, GraphQLArg{
			Name:     "last",
			Key:      "last",
			TypeName: "Int",
			Value:    *params.Last,
		})
	}

	stack = append(stack, Instruction{
		Name: "links",
		Field: GraphQLField{
			Name:       "links",
			TypeName:   "Link",
			TypeFields: []string{"id", "createdAt", "description", "url"},
		},
		Operation: "query",
		Args:      args,
	})

	return &LinkExecArray{
		client: client,
		stack:  stack,
	}
}

// Exists

// LinksConnection exists docs
func (exists *Exists) LinksConnection(params *LinkWhereInput) bool {
	client := Client{
		Endpoint: (map[bool]string{true: exists.Endpoint, false: "http://localhost:4466"})[exists.Endpoint != ""],
		Debug:    exists.Debug,
	}
	data, err := client.LinksConnection(
		&LinksConnectionParams{
			Where: params,
		},
	).Exec()
	if err != nil {
		if client.Debug {
			fmt.Println("Error Exists", err)
		}
		return false
	}
	if isZeroOfUnderlyingType(data) {
		return false
	}
	return true
}

// LinksConnectionParams docs
type LinksConnectionParams struct {
	Where   *LinkWhereInput   `json:"where,omitempty"`
	OrderBy *LinkOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

// LinksConnection docs - generated while printing operation - query
func (client Client) LinksConnection(params *LinksConnectionParams) *LinkConnectionExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil && params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "LinkWhereInput",
			Value:    *params.Where,
		})
	}
	if params != nil && params.OrderBy != nil {
		args = append(args, GraphQLArg{
			Name:     "orderBy",
			Key:      "orderBy",
			TypeName: "LinkOrderByInput",
			Value:    *params.OrderBy,
		})
	}
	if params != nil && params.Skip != nil {
		args = append(args, GraphQLArg{
			Name:     "skip",
			Key:      "skip",
			TypeName: "Int",
			Value:    *params.Skip,
		})
	}
	if params != nil && params.After != nil {
		args = append(args, GraphQLArg{
			Name:     "after",
			Key:      "after",
			TypeName: "String",
			Value:    *params.After,
		})
	}
	if params != nil && params.Before != nil {
		args = append(args, GraphQLArg{
			Name:     "before",
			Key:      "before",
			TypeName: "String",
			Value:    *params.Before,
		})
	}
	if params != nil && params.First != nil {
		args = append(args, GraphQLArg{
			Name:     "first",
			Key:      "first",
			TypeName: "Int",
			Value:    *params.First,
		})
	}
	if params != nil && params.Last != nil {
		args = append(args, GraphQLArg{
			Name:     "last",
			Key:      "last",
			TypeName: "Int",
			Value:    *params.Last,
		})
	}

	stack = append(stack, Instruction{
		Name: "linksConnection",
		Field: GraphQLField{
			Name:       "linksConnection",
			TypeName:   "LinkConnection",
			TypeFields: []string{},
		},
		Operation: "query",
		Args:      args,
	})

	return &LinkConnectionExec{
		client: client,
		stack:  stack,
	}
}

// Exists

// User exists docs
func (exists *Exists) User(params *UserWhereUniqueInput) bool {
	client := Client{
		Endpoint: (map[bool]string{true: exists.Endpoint, false: "http://localhost:4466"})[exists.Endpoint != ""],
		Debug:    exists.Debug,
	}
	data, err := client.User(
		params,
	).Exec()
	if err != nil {
		if client.Debug {
			fmt.Println("Error Exists", err)
		}
		return false
	}
	if isZeroOfUnderlyingType(data) {
		return false
	}
	return true
}

// UserParams docs
type UserParams struct {
	Where *UserWhereUniqueInput `json:"where"`
}

// User docs - generated while printing operation - query
func (client Client) User(params *UserWhereUniqueInput) *UserExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "UserWhereUniqueInput!",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "user",
		Field: GraphQLField{
			Name:       "user",
			TypeName:   "User",
			TypeFields: []string{"id", "name", "email", "password"},
		},
		Operation: "query",
		Args:      args,
	})

	return &UserExec{
		client: client,
		stack:  stack,
	}
}

// UsersParams docs
type UsersParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

// Users docs - generated while printing operation - query
func (client Client) Users(params *UsersParams) *UserExecArray {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil && params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "UserWhereInput",
			Value:    *params.Where,
		})
	}
	if params != nil && params.OrderBy != nil {
		args = append(args, GraphQLArg{
			Name:     "orderBy",
			Key:      "orderBy",
			TypeName: "UserOrderByInput",
			Value:    *params.OrderBy,
		})
	}
	if params != nil && params.Skip != nil {
		args = append(args, GraphQLArg{
			Name:     "skip",
			Key:      "skip",
			TypeName: "Int",
			Value:    *params.Skip,
		})
	}
	if params != nil && params.After != nil {
		args = append(args, GraphQLArg{
			Name:     "after",
			Key:      "after",
			TypeName: "String",
			Value:    *params.After,
		})
	}
	if params != nil && params.Before != nil {
		args = append(args, GraphQLArg{
			Name:     "before",
			Key:      "before",
			TypeName: "String",
			Value:    *params.Before,
		})
	}
	if params != nil && params.First != nil {
		args = append(args, GraphQLArg{
			Name:     "first",
			Key:      "first",
			TypeName: "Int",
			Value:    *params.First,
		})
	}
	if params != nil && params.Last != nil {
		args = append(args, GraphQLArg{
			Name:     "last",
			Key:      "last",
			TypeName: "Int",
			Value:    *params.Last,
		})
	}

	stack = append(stack, Instruction{
		Name: "users",
		Field: GraphQLField{
			Name:       "users",
			TypeName:   "User",
			TypeFields: []string{"id", "name", "email", "password"},
		},
		Operation: "query",
		Args:      args,
	})

	return &UserExecArray{
		client: client,
		stack:  stack,
	}
}

// Exists

// UsersConnection exists docs
func (exists *Exists) UsersConnection(params *UserWhereInput) bool {
	client := Client{
		Endpoint: (map[bool]string{true: exists.Endpoint, false: "http://localhost:4466"})[exists.Endpoint != ""],
		Debug:    exists.Debug,
	}
	data, err := client.UsersConnection(
		&UsersConnectionParams{
			Where: params,
		},
	).Exec()
	if err != nil {
		if client.Debug {
			fmt.Println("Error Exists", err)
		}
		return false
	}
	if isZeroOfUnderlyingType(data) {
		return false
	}
	return true
}

// UsersConnectionParams docs
type UsersConnectionParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

// UsersConnection docs - generated while printing operation - query
func (client Client) UsersConnection(params *UsersConnectionParams) *UserConnectionExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil && params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "UserWhereInput",
			Value:    *params.Where,
		})
	}
	if params != nil && params.OrderBy != nil {
		args = append(args, GraphQLArg{
			Name:     "orderBy",
			Key:      "orderBy",
			TypeName: "UserOrderByInput",
			Value:    *params.OrderBy,
		})
	}
	if params != nil && params.Skip != nil {
		args = append(args, GraphQLArg{
			Name:     "skip",
			Key:      "skip",
			TypeName: "Int",
			Value:    *params.Skip,
		})
	}
	if params != nil && params.After != nil {
		args = append(args, GraphQLArg{
			Name:     "after",
			Key:      "after",
			TypeName: "String",
			Value:    *params.After,
		})
	}
	if params != nil && params.Before != nil {
		args = append(args, GraphQLArg{
			Name:     "before",
			Key:      "before",
			TypeName: "String",
			Value:    *params.Before,
		})
	}
	if params != nil && params.First != nil {
		args = append(args, GraphQLArg{
			Name:     "first",
			Key:      "first",
			TypeName: "Int",
			Value:    *params.First,
		})
	}
	if params != nil && params.Last != nil {
		args = append(args, GraphQLArg{
			Name:     "last",
			Key:      "last",
			TypeName: "Int",
			Value:    *params.Last,
		})
	}

	stack = append(stack, Instruction{
		Name: "usersConnection",
		Field: GraphQLField{
			Name:       "usersConnection",
			TypeName:   "UserConnection",
			TypeFields: []string{},
		},
		Operation: "query",
		Args:      args,
	})

	return &UserConnectionExec{
		client: client,
		stack:  stack,
	}
}

// Exists

// Vote exists docs
func (exists *Exists) Vote(params *VoteWhereUniqueInput) bool {
	client := Client{
		Endpoint: (map[bool]string{true: exists.Endpoint, false: "http://localhost:4466"})[exists.Endpoint != ""],
		Debug:    exists.Debug,
	}
	data, err := client.Vote(
		params,
	).Exec()
	if err != nil {
		if client.Debug {
			fmt.Println("Error Exists", err)
		}
		return false
	}
	if isZeroOfUnderlyingType(data) {
		return false
	}
	return true
}

// VoteParams docs
type VoteParams struct {
	Where *VoteWhereUniqueInput `json:"where"`
}

// Vote docs - generated while printing operation - query
func (client Client) Vote(params *VoteWhereUniqueInput) *VoteExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "VoteWhereUniqueInput!",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "vote",
		Field: GraphQLField{
			Name:       "vote",
			TypeName:   "Vote",
			TypeFields: []string{"id"},
		},
		Operation: "query",
		Args:      args,
	})

	return &VoteExec{
		client: client,
		stack:  stack,
	}
}

// VotesParams docs
type VotesParams struct {
	Where   *VoteWhereInput   `json:"where,omitempty"`
	OrderBy *VoteOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

// Votes docs - generated while printing operation - query
func (client Client) Votes(params *VotesParams) *VoteExecArray {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil && params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "VoteWhereInput",
			Value:    *params.Where,
		})
	}
	if params != nil && params.OrderBy != nil {
		args = append(args, GraphQLArg{
			Name:     "orderBy",
			Key:      "orderBy",
			TypeName: "VoteOrderByInput",
			Value:    *params.OrderBy,
		})
	}
	if params != nil && params.Skip != nil {
		args = append(args, GraphQLArg{
			Name:     "skip",
			Key:      "skip",
			TypeName: "Int",
			Value:    *params.Skip,
		})
	}
	if params != nil && params.After != nil {
		args = append(args, GraphQLArg{
			Name:     "after",
			Key:      "after",
			TypeName: "String",
			Value:    *params.After,
		})
	}
	if params != nil && params.Before != nil {
		args = append(args, GraphQLArg{
			Name:     "before",
			Key:      "before",
			TypeName: "String",
			Value:    *params.Before,
		})
	}
	if params != nil && params.First != nil {
		args = append(args, GraphQLArg{
			Name:     "first",
			Key:      "first",
			TypeName: "Int",
			Value:    *params.First,
		})
	}
	if params != nil && params.Last != nil {
		args = append(args, GraphQLArg{
			Name:     "last",
			Key:      "last",
			TypeName: "Int",
			Value:    *params.Last,
		})
	}

	stack = append(stack, Instruction{
		Name: "votes",
		Field: GraphQLField{
			Name:       "votes",
			TypeName:   "Vote",
			TypeFields: []string{"id"},
		},
		Operation: "query",
		Args:      args,
	})

	return &VoteExecArray{
		client: client,
		stack:  stack,
	}
}

// Exists

// VotesConnection exists docs
func (exists *Exists) VotesConnection(params *VoteWhereInput) bool {
	client := Client{
		Endpoint: (map[bool]string{true: exists.Endpoint, false: "http://localhost:4466"})[exists.Endpoint != ""],
		Debug:    exists.Debug,
	}
	data, err := client.VotesConnection(
		&VotesConnectionParams{
			Where: params,
		},
	).Exec()
	if err != nil {
		if client.Debug {
			fmt.Println("Error Exists", err)
		}
		return false
	}
	if isZeroOfUnderlyingType(data) {
		return false
	}
	return true
}

// VotesConnectionParams docs
type VotesConnectionParams struct {
	Where   *VoteWhereInput   `json:"where,omitempty"`
	OrderBy *VoteOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

// VotesConnection docs - generated while printing operation - query
func (client Client) VotesConnection(params *VotesConnectionParams) *VoteConnectionExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil && params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "VoteWhereInput",
			Value:    *params.Where,
		})
	}
	if params != nil && params.OrderBy != nil {
		args = append(args, GraphQLArg{
			Name:     "orderBy",
			Key:      "orderBy",
			TypeName: "VoteOrderByInput",
			Value:    *params.OrderBy,
		})
	}
	if params != nil && params.Skip != nil {
		args = append(args, GraphQLArg{
			Name:     "skip",
			Key:      "skip",
			TypeName: "Int",
			Value:    *params.Skip,
		})
	}
	if params != nil && params.After != nil {
		args = append(args, GraphQLArg{
			Name:     "after",
			Key:      "after",
			TypeName: "String",
			Value:    *params.After,
		})
	}
	if params != nil && params.Before != nil {
		args = append(args, GraphQLArg{
			Name:     "before",
			Key:      "before",
			TypeName: "String",
			Value:    *params.Before,
		})
	}
	if params != nil && params.First != nil {
		args = append(args, GraphQLArg{
			Name:     "first",
			Key:      "first",
			TypeName: "Int",
			Value:    *params.First,
		})
	}
	if params != nil && params.Last != nil {
		args = append(args, GraphQLArg{
			Name:     "last",
			Key:      "last",
			TypeName: "Int",
			Value:    *params.Last,
		})
	}

	stack = append(stack, Instruction{
		Name: "votesConnection",
		Field: GraphQLField{
			Name:       "votesConnection",
			TypeName:   "VoteConnection",
			TypeFields: []string{},
		},
		Operation: "query",
		Args:      args,
	})

	return &VoteConnectionExec{
		client: client,
		stack:  stack,
	}
}

// NodeParams docs
type NodeParams struct {
	ID *string `json:"id"`
}

// Node docs - generated while printing operation - query
func (client Client) Node(params *ID) *NodeExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "id",
			Key:      "id",
			TypeName: "ID!",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "node",
		Field: GraphQLField{
			Name:       "node",
			TypeName:   "Node",
			TypeFields: []string{},
		},
		Operation: "query",
		Args:      args,
	})

	return &NodeExec{
		client: client,
		stack:  stack,
	}
}

// Mutations

// CreateLinkParams docs
type CreateLinkParams struct {
	Data *LinkCreateInput `json:"data"`
}

// CreateLink docs - generated while printing operation - mutation
func (client Client) CreateLink(params *LinkCreateInput) *LinkExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "data",
			Key:      "data",
			TypeName: "LinkCreateInput!",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "createLink",
		Field: GraphQLField{
			Name:       "createLink",
			TypeName:   "Link",
			TypeFields: []string{"id", "createdAt", "description", "url"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &LinkExec{
		client: client,
		stack:  stack,
	}
}

// UpdateLinkParams docs
type UpdateLinkParams struct {
	Data  *LinkUpdateInput      `json:"data"`
	Where *LinkWhereUniqueInput `json:"where"`
}

// UpdateLink docs - generated while printing operation - mutation
func (client Client) UpdateLink(params *UpdateLinkParams) *LinkExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil && params.Data != nil {
		args = append(args, GraphQLArg{
			Name:     "data",
			Key:      "data",
			TypeName: "LinkUpdateInput!",
			Value:    *params.Data,
		})
	}
	if params != nil && params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "LinkWhereUniqueInput!",
			Value:    *params.Where,
		})
	}

	stack = append(stack, Instruction{
		Name: "updateLink",
		Field: GraphQLField{
			Name:       "updateLink",
			TypeName:   "Link",
			TypeFields: []string{"id", "createdAt", "description", "url"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &LinkExec{
		client: client,
		stack:  stack,
	}
}

// UpdateManyLinksParams docs
type UpdateManyLinksParams struct {
	Data  *LinkUpdateInput `json:"data"`
	Where *LinkWhereInput  `json:"where,omitempty"`
}

// UpdateManyLinks docs - generated while printing operation - mutation
func (client Client) UpdateManyLinks(params *UpdateManyLinksParams) *BatchPayloadExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil && params.Data != nil {
		args = append(args, GraphQLArg{
			Name:     "data",
			Key:      "data",
			TypeName: "LinkUpdateInput!",
			Value:    *params.Data,
		})
	}
	if params != nil && params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "LinkWhereInput",
			Value:    *params.Where,
		})
	}

	stack = append(stack, Instruction{
		Name: "updateManyLinks",
		Field: GraphQLField{
			Name:       "updateManyLinks",
			TypeName:   "BatchPayload",
			TypeFields: []string{"count"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &BatchPayloadExec{
		client: client,
		stack:  stack,
	}
}

// UpsertLinkParams docs
type UpsertLinkParams struct {
	Where  *LinkWhereUniqueInput `json:"where"`
	Create *LinkCreateInput      `json:"create"`
	Update *LinkUpdateInput      `json:"update"`
}

// UpsertLink docs - generated while printing operation - mutation
func (client Client) UpsertLink(params *UpsertLinkParams) *LinkExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil && params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "LinkWhereUniqueInput!",
			Value:    *params.Where,
		})
	}
	if params != nil && params.Create != nil {
		args = append(args, GraphQLArg{
			Name:     "create",
			Key:      "create",
			TypeName: "LinkCreateInput!",
			Value:    *params.Create,
		})
	}
	if params != nil && params.Update != nil {
		args = append(args, GraphQLArg{
			Name:     "update",
			Key:      "update",
			TypeName: "LinkUpdateInput!",
			Value:    *params.Update,
		})
	}

	stack = append(stack, Instruction{
		Name: "upsertLink",
		Field: GraphQLField{
			Name:       "upsertLink",
			TypeName:   "Link",
			TypeFields: []string{"id", "createdAt", "description", "url"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &LinkExec{
		client: client,
		stack:  stack,
	}
}

// DeleteLinkParams docs
type DeleteLinkParams struct {
	Where *LinkWhereUniqueInput `json:"where"`
}

// DeleteLink docs - generated while printing operation - mutation
func (client Client) DeleteLink(params *LinkWhereUniqueInput) *LinkExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "LinkWhereUniqueInput!",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "deleteLink",
		Field: GraphQLField{
			Name:       "deleteLink",
			TypeName:   "Link",
			TypeFields: []string{"id", "createdAt", "description", "url"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &LinkExec{
		client: client,
		stack:  stack,
	}
}

// DeleteManyLinksParams docs
type DeleteManyLinksParams struct {
	Where *LinkWhereInput `json:"where,omitempty"`
}

// DeleteManyLinks docs - generated while printing operation - mutation
func (client Client) DeleteManyLinks(params *LinkWhereInput) *BatchPayloadExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "LinkWhereInput",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "deleteManyLinks",
		Field: GraphQLField{
			Name:       "deleteManyLinks",
			TypeName:   "BatchPayload",
			TypeFields: []string{"count"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &BatchPayloadExec{
		client: client,
		stack:  stack,
	}
}

// CreateUserParams docs
type CreateUserParams struct {
	Data *UserCreateInput `json:"data"`
}

// CreateUser docs - generated while printing operation - mutation
func (client Client) CreateUser(params *UserCreateInput) *UserExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "data",
			Key:      "data",
			TypeName: "UserCreateInput!",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "createUser",
		Field: GraphQLField{
			Name:       "createUser",
			TypeName:   "User",
			TypeFields: []string{"id", "name", "email", "password"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &UserExec{
		client: client,
		stack:  stack,
	}
}

// UpdateUserParams docs
type UpdateUserParams struct {
	Data  *UserUpdateInput      `json:"data"`
	Where *UserWhereUniqueInput `json:"where"`
}

// UpdateUser docs - generated while printing operation - mutation
func (client Client) UpdateUser(params *UpdateUserParams) *UserExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil && params.Data != nil {
		args = append(args, GraphQLArg{
			Name:     "data",
			Key:      "data",
			TypeName: "UserUpdateInput!",
			Value:    *params.Data,
		})
	}
	if params != nil && params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "UserWhereUniqueInput!",
			Value:    *params.Where,
		})
	}

	stack = append(stack, Instruction{
		Name: "updateUser",
		Field: GraphQLField{
			Name:       "updateUser",
			TypeName:   "User",
			TypeFields: []string{"id", "name", "email", "password"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &UserExec{
		client: client,
		stack:  stack,
	}
}

// UpdateManyUsersParams docs
type UpdateManyUsersParams struct {
	Data  *UserUpdateInput `json:"data"`
	Where *UserWhereInput  `json:"where,omitempty"`
}

// UpdateManyUsers docs - generated while printing operation - mutation
func (client Client) UpdateManyUsers(params *UpdateManyUsersParams) *BatchPayloadExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil && params.Data != nil {
		args = append(args, GraphQLArg{
			Name:     "data",
			Key:      "data",
			TypeName: "UserUpdateInput!",
			Value:    *params.Data,
		})
	}
	if params != nil && params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "UserWhereInput",
			Value:    *params.Where,
		})
	}

	stack = append(stack, Instruction{
		Name: "updateManyUsers",
		Field: GraphQLField{
			Name:       "updateManyUsers",
			TypeName:   "BatchPayload",
			TypeFields: []string{"count"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &BatchPayloadExec{
		client: client,
		stack:  stack,
	}
}

// UpsertUserParams docs
type UpsertUserParams struct {
	Where  *UserWhereUniqueInput `json:"where"`
	Create *UserCreateInput      `json:"create"`
	Update *UserUpdateInput      `json:"update"`
}

// UpsertUser docs - generated while printing operation - mutation
func (client Client) UpsertUser(params *UpsertUserParams) *UserExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil && params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "UserWhereUniqueInput!",
			Value:    *params.Where,
		})
	}
	if params != nil && params.Create != nil {
		args = append(args, GraphQLArg{
			Name:     "create",
			Key:      "create",
			TypeName: "UserCreateInput!",
			Value:    *params.Create,
		})
	}
	if params != nil && params.Update != nil {
		args = append(args, GraphQLArg{
			Name:     "update",
			Key:      "update",
			TypeName: "UserUpdateInput!",
			Value:    *params.Update,
		})
	}

	stack = append(stack, Instruction{
		Name: "upsertUser",
		Field: GraphQLField{
			Name:       "upsertUser",
			TypeName:   "User",
			TypeFields: []string{"id", "name", "email", "password"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &UserExec{
		client: client,
		stack:  stack,
	}
}

// DeleteUserParams docs
type DeleteUserParams struct {
	Where *UserWhereUniqueInput `json:"where"`
}

// DeleteUser docs - generated while printing operation - mutation
func (client Client) DeleteUser(params *UserWhereUniqueInput) *UserExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "UserWhereUniqueInput!",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "deleteUser",
		Field: GraphQLField{
			Name:       "deleteUser",
			TypeName:   "User",
			TypeFields: []string{"id", "name", "email", "password"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &UserExec{
		client: client,
		stack:  stack,
	}
}

// DeleteManyUsersParams docs
type DeleteManyUsersParams struct {
	Where *UserWhereInput `json:"where,omitempty"`
}

// DeleteManyUsers docs - generated while printing operation - mutation
func (client Client) DeleteManyUsers(params *UserWhereInput) *BatchPayloadExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "UserWhereInput",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "deleteManyUsers",
		Field: GraphQLField{
			Name:       "deleteManyUsers",
			TypeName:   "BatchPayload",
			TypeFields: []string{"count"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &BatchPayloadExec{
		client: client,
		stack:  stack,
	}
}

// CreateVoteParams docs
type CreateVoteParams struct {
	Data *VoteCreateInput `json:"data"`
}

// CreateVote docs - generated while printing operation - mutation
func (client Client) CreateVote(params *VoteCreateInput) *VoteExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "data",
			Key:      "data",
			TypeName: "VoteCreateInput!",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "createVote",
		Field: GraphQLField{
			Name:       "createVote",
			TypeName:   "Vote",
			TypeFields: []string{"id"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &VoteExec{
		client: client,
		stack:  stack,
	}
}

// UpdateVoteParams docs
type UpdateVoteParams struct {
	Data  *VoteUpdateInput      `json:"data"`
	Where *VoteWhereUniqueInput `json:"where"`
}

// UpdateVote docs - generated while printing operation - mutation
func (client Client) UpdateVote(params *UpdateVoteParams) *VoteExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil && params.Data != nil {
		args = append(args, GraphQLArg{
			Name:     "data",
			Key:      "data",
			TypeName: "VoteUpdateInput!",
			Value:    *params.Data,
		})
	}
	if params != nil && params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "VoteWhereUniqueInput!",
			Value:    *params.Where,
		})
	}

	stack = append(stack, Instruction{
		Name: "updateVote",
		Field: GraphQLField{
			Name:       "updateVote",
			TypeName:   "Vote",
			TypeFields: []string{"id"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &VoteExec{
		client: client,
		stack:  stack,
	}
}

// UpdateManyVotesParams docs
type UpdateManyVotesParams struct {
	Data  *VoteUpdateInput `json:"data"`
	Where *VoteWhereInput  `json:"where,omitempty"`
}

// UpdateManyVotes docs - generated while printing operation - mutation
func (client Client) UpdateManyVotes(params *UpdateManyVotesParams) *BatchPayloadExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil && params.Data != nil {
		args = append(args, GraphQLArg{
			Name:     "data",
			Key:      "data",
			TypeName: "VoteUpdateInput!",
			Value:    *params.Data,
		})
	}
	if params != nil && params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "VoteWhereInput",
			Value:    *params.Where,
		})
	}

	stack = append(stack, Instruction{
		Name: "updateManyVotes",
		Field: GraphQLField{
			Name:       "updateManyVotes",
			TypeName:   "BatchPayload",
			TypeFields: []string{"count"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &BatchPayloadExec{
		client: client,
		stack:  stack,
	}
}

// UpsertVoteParams docs
type UpsertVoteParams struct {
	Where  *VoteWhereUniqueInput `json:"where"`
	Create *VoteCreateInput      `json:"create"`
	Update *VoteUpdateInput      `json:"update"`
}

// UpsertVote docs - generated while printing operation - mutation
func (client Client) UpsertVote(params *UpsertVoteParams) *VoteExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil && params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "VoteWhereUniqueInput!",
			Value:    *params.Where,
		})
	}
	if params != nil && params.Create != nil {
		args = append(args, GraphQLArg{
			Name:     "create",
			Key:      "create",
			TypeName: "VoteCreateInput!",
			Value:    *params.Create,
		})
	}
	if params != nil && params.Update != nil {
		args = append(args, GraphQLArg{
			Name:     "update",
			Key:      "update",
			TypeName: "VoteUpdateInput!",
			Value:    *params.Update,
		})
	}

	stack = append(stack, Instruction{
		Name: "upsertVote",
		Field: GraphQLField{
			Name:       "upsertVote",
			TypeName:   "Vote",
			TypeFields: []string{"id"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &VoteExec{
		client: client,
		stack:  stack,
	}
}

// DeleteVoteParams docs
type DeleteVoteParams struct {
	Where *VoteWhereUniqueInput `json:"where"`
}

// DeleteVote docs - generated while printing operation - mutation
func (client Client) DeleteVote(params *VoteWhereUniqueInput) *VoteExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "VoteWhereUniqueInput!",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "deleteVote",
		Field: GraphQLField{
			Name:       "deleteVote",
			TypeName:   "Vote",
			TypeFields: []string{"id"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &VoteExec{
		client: client,
		stack:  stack,
	}
}

// DeleteManyVotesParams docs
type DeleteManyVotesParams struct {
	Where *VoteWhereInput `json:"where,omitempty"`
}

// DeleteManyVotes docs - generated while printing operation - mutation
func (client Client) DeleteManyVotes(params *VoteWhereInput) *BatchPayloadExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "VoteWhereInput",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "deleteManyVotes",
		Field: GraphQLField{
			Name:       "deleteManyVotes",
			TypeName:   "BatchPayload",
			TypeFields: []string{"count"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &BatchPayloadExec{
		client: client,
		stack:  stack,
	}
}

// Types

// LinkOrderByInput docs
type LinkOrderByInput string

const (

	// IDAscLinkOrderByInput docs
	IDAscLinkOrderByInput LinkOrderByInput = "id_ASC"

	// IDDescLinkOrderByInput docs
	IDDescLinkOrderByInput LinkOrderByInput = "id_DESC"

	// CreatedAtAscLinkOrderByInput docs
	CreatedAtAscLinkOrderByInput LinkOrderByInput = "createdAt_ASC"

	// CreatedAtDescLinkOrderByInput docs
	CreatedAtDescLinkOrderByInput LinkOrderByInput = "createdAt_DESC"

	// DescriptionAscLinkOrderByInput docs
	DescriptionAscLinkOrderByInput LinkOrderByInput = "description_ASC"

	// DescriptionDescLinkOrderByInput docs
	DescriptionDescLinkOrderByInput LinkOrderByInput = "description_DESC"

	// UrlAscLinkOrderByInput docs
	UrlAscLinkOrderByInput LinkOrderByInput = "url_ASC"

	// UrlDescLinkOrderByInput docs
	UrlDescLinkOrderByInput LinkOrderByInput = "url_DESC"

	// UpdatedAtAscLinkOrderByInput docs
	UpdatedAtAscLinkOrderByInput LinkOrderByInput = "updatedAt_ASC"

	// UpdatedAtDescLinkOrderByInput docs
	UpdatedAtDescLinkOrderByInput LinkOrderByInput = "updatedAt_DESC"
)

// VoteOrderByInput docs
type VoteOrderByInput string

const (

	// IDAscVoteOrderByInput docs
	IDAscVoteOrderByInput VoteOrderByInput = "id_ASC"

	// IDDescVoteOrderByInput docs
	IDDescVoteOrderByInput VoteOrderByInput = "id_DESC"

	// CreatedAtAscVoteOrderByInput docs
	CreatedAtAscVoteOrderByInput VoteOrderByInput = "createdAt_ASC"

	// CreatedAtDescVoteOrderByInput docs
	CreatedAtDescVoteOrderByInput VoteOrderByInput = "createdAt_DESC"

	// UpdatedAtAscVoteOrderByInput docs
	UpdatedAtAscVoteOrderByInput VoteOrderByInput = "updatedAt_ASC"

	// UpdatedAtDescVoteOrderByInput docs
	UpdatedAtDescVoteOrderByInput VoteOrderByInput = "updatedAt_DESC"
)

// UserOrderByInput docs
type UserOrderByInput string

const (

	// IDAscUserOrderByInput docs
	IDAscUserOrderByInput UserOrderByInput = "id_ASC"

	// IDDescUserOrderByInput docs
	IDDescUserOrderByInput UserOrderByInput = "id_DESC"

	// NameAscUserOrderByInput docs
	NameAscUserOrderByInput UserOrderByInput = "name_ASC"

	// NameDescUserOrderByInput docs
	NameDescUserOrderByInput UserOrderByInput = "name_DESC"

	// EmailAscUserOrderByInput docs
	EmailAscUserOrderByInput UserOrderByInput = "email_ASC"

	// EmailDescUserOrderByInput docs
	EmailDescUserOrderByInput UserOrderByInput = "email_DESC"

	// PasswordAscUserOrderByInput docs
	PasswordAscUserOrderByInput UserOrderByInput = "password_ASC"

	// PasswordDescUserOrderByInput docs
	PasswordDescUserOrderByInput UserOrderByInput = "password_DESC"

	// CreatedAtAscUserOrderByInput docs
	CreatedAtAscUserOrderByInput UserOrderByInput = "createdAt_ASC"

	// CreatedAtDescUserOrderByInput docs
	CreatedAtDescUserOrderByInput UserOrderByInput = "createdAt_DESC"

	// UpdatedAtAscUserOrderByInput docs
	UpdatedAtAscUserOrderByInput UserOrderByInput = "updatedAt_ASC"

	// UpdatedAtDescUserOrderByInput docs
	UpdatedAtDescUserOrderByInput UserOrderByInput = "updatedAt_DESC"
)

// MutationType docs
type MutationType string

const (

	// CreatedMutationType docs
	CreatedMutationType MutationType = "CREATED"

	// UpdatedMutationType docs
	UpdatedMutationType MutationType = "UPDATED"

	// DeletedMutationType docs
	DeletedMutationType MutationType = "DELETED"
)

// LinkCreateManyWithoutPostedByInput input struct docs
type LinkCreateManyWithoutPostedByInput struct {
	Create  *LinkCreateWithoutPostedByInput `json:"create,omitempty"`
	Connect *LinkWhereUniqueInput           `json:"connect,omitempty"`
}

// LinkWhereUniqueInput input struct docs
type LinkWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

// UserUpdateOneWithoutLinksInput input struct docs
type UserUpdateOneWithoutLinksInput struct {
	Create     *UserCreateWithoutLinksInput     `json:"create,omitempty"`
	Update     *UserUpdateWithoutLinksDataInput `json:"update,omitempty"`
	Upsert     *UserUpsertWithoutLinksInput     `json:"upsert,omitempty"`
	Delete     *bool                            `json:"delete,omitempty"`
	Disconnect *bool                            `json:"disconnect,omitempty"`
	Connect    *UserWhereUniqueInput            `json:"connect,omitempty"`
}

// LinkWhereInput input struct docs
type LinkWhereInput struct {
	ID                       *string         `json:"id,omitempty"`
	IDNot                    *string         `json:"id_not,omitempty"`
	IDIn                     *string         `json:"id_in,omitempty"`
	IDNotIn                  *string         `json:"id_not_in,omitempty"`
	IDLt                     *string         `json:"id_lt,omitempty"`
	IDLte                    *string         `json:"id_lte,omitempty"`
	IDGt                     *string         `json:"id_gt,omitempty"`
	IDGte                    *string         `json:"id_gte,omitempty"`
	IDContains               *string         `json:"id_contains,omitempty"`
	IDNotContains            *string         `json:"id_not_contains,omitempty"`
	IDStartsWith             *string         `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string         `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string         `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string         `json:"id_not_ends_with,omitempty"`
	CreatedAt                *string         `json:"createdAt,omitempty"`
	CreatedAtNot             *string         `json:"createdAt_not,omitempty"`
	CreatedAtIn              *string         `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           *string         `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string         `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string         `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string         `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string         `json:"createdAt_gte,omitempty"`
	Description              *string         `json:"description,omitempty"`
	DescriptionNot           *string         `json:"description_not,omitempty"`
	DescriptionIn            *string         `json:"description_in,omitempty"`
	DescriptionNotIn         *string         `json:"description_not_in,omitempty"`
	DescriptionLt            *string         `json:"description_lt,omitempty"`
	DescriptionLte           *string         `json:"description_lte,omitempty"`
	DescriptionGt            *string         `json:"description_gt,omitempty"`
	DescriptionGte           *string         `json:"description_gte,omitempty"`
	DescriptionContains      *string         `json:"description_contains,omitempty"`
	DescriptionNotContains   *string         `json:"description_not_contains,omitempty"`
	DescriptionStartsWith    *string         `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith *string         `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith      *string         `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith   *string         `json:"description_not_ends_with,omitempty"`
	Url                      *string         `json:"url,omitempty"`
	UrlNot                   *string         `json:"url_not,omitempty"`
	UrlIn                    *string         `json:"url_in,omitempty"`
	UrlNotIn                 *string         `json:"url_not_in,omitempty"`
	UrlLt                    *string         `json:"url_lt,omitempty"`
	UrlLte                   *string         `json:"url_lte,omitempty"`
	UrlGt                    *string         `json:"url_gt,omitempty"`
	UrlGte                   *string         `json:"url_gte,omitempty"`
	UrlContains              *string         `json:"url_contains,omitempty"`
	UrlNotContains           *string         `json:"url_not_contains,omitempty"`
	UrlStartsWith            *string         `json:"url_starts_with,omitempty"`
	UrlNotStartsWith         *string         `json:"url_not_starts_with,omitempty"`
	UrlEndsWith              *string         `json:"url_ends_with,omitempty"`
	UrlNotEndsWith           *string         `json:"url_not_ends_with,omitempty"`
	PostedBy                 *UserWhereInput `json:"postedBy,omitempty"`
	AllVotesEvery            *VoteWhereInput `json:"allVotes_every,omitempty"`
	AllVotesSome             *VoteWhereInput `json:"allVotes_some,omitempty"`
	AllVotesNone             *VoteWhereInput `json:"allVotes_none,omitempty"`
	And                      *LinkWhereInput `json:"AND,omitempty"`
	Or                       *LinkWhereInput `json:"OR,omitempty"`
	Not                      *LinkWhereInput `json:"NOT,omitempty"`
}

// UserUpdateWithoutLinksDataInput input struct docs
type UserUpdateWithoutLinksDataInput struct {
	Name     *string                            `json:"name,omitempty"`
	Email    *string                            `json:"email,omitempty"`
	Password *string                            `json:"password,omitempty"`
	Votes    *VoteUpdateManyWithoutVotedByInput `json:"votes,omitempty"`
}

// VoteWhereInput input struct docs
type VoteWhereInput struct {
	ID              *string         `json:"id,omitempty"`
	IDNot           *string         `json:"id_not,omitempty"`
	IDIn            *string         `json:"id_in,omitempty"`
	IDNotIn         *string         `json:"id_not_in,omitempty"`
	IDLt            *string         `json:"id_lt,omitempty"`
	IDLte           *string         `json:"id_lte,omitempty"`
	IDGt            *string         `json:"id_gt,omitempty"`
	IDGte           *string         `json:"id_gte,omitempty"`
	IDContains      *string         `json:"id_contains,omitempty"`
	IDNotContains   *string         `json:"id_not_contains,omitempty"`
	IDStartsWith    *string         `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string         `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string         `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string         `json:"id_not_ends_with,omitempty"`
	Link            *LinkWhereInput `json:"link,omitempty"`
	VotedBy         *UserWhereInput `json:"votedBy,omitempty"`
	And             *VoteWhereInput `json:"AND,omitempty"`
	Or              *VoteWhereInput `json:"OR,omitempty"`
	Not             *VoteWhereInput `json:"NOT,omitempty"`
}

// VoteCreateWithoutVotedByInput input struct docs
type VoteCreateWithoutVotedByInput struct {
	Link *LinkCreateOneWithoutAllVotesInput `json:"link,omitempty"`
}

// VoteUpdateWithWhereUniqueWithoutLinkInput input struct docs
type VoteUpdateWithWhereUniqueWithoutLinkInput struct {
	Where *VoteWhereUniqueInput           `json:"where,omitempty"`
	Data  *VoteUpdateWithoutLinkDataInput `json:"data,omitempty"`
}

// LinkCreateOneWithoutAllVotesInput input struct docs
type LinkCreateOneWithoutAllVotesInput struct {
	Create  *LinkCreateWithoutAllVotesInput `json:"create,omitempty"`
	Connect *LinkWhereUniqueInput           `json:"connect,omitempty"`
}

// VoteUpdateManyWithoutVotedByInput input struct docs
type VoteUpdateManyWithoutVotedByInput struct {
	Create     *VoteCreateWithoutVotedByInput                `json:"create,omitempty"`
	Delete     *VoteWhereUniqueInput                         `json:"delete,omitempty"`
	Connect    *VoteWhereUniqueInput                         `json:"connect,omitempty"`
	Disconnect *VoteWhereUniqueInput                         `json:"disconnect,omitempty"`
	Update     *VoteUpdateWithWhereUniqueWithoutVotedByInput `json:"update,omitempty"`
	Upsert     *VoteUpsertWithWhereUniqueWithoutVotedByInput `json:"upsert,omitempty"`
}

// LinkCreateWithoutAllVotesInput input struct docs
type LinkCreateWithoutAllVotesInput struct {
	Description *string                         `json:"description,omitempty"`
	Url         *string                         `json:"url,omitempty"`
	PostedBy    *UserCreateOneWithoutLinksInput `json:"postedBy,omitempty"`
}

// UserSubscriptionWhereInput input struct docs
type UserSubscriptionWhereInput struct {
	MutationIn                 *MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                     `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery *string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  *string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *UserWhereInput             `json:"node,omitempty"`
	And                        *UserSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         *UserSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        *UserSubscriptionWhereInput `json:"NOT,omitempty"`
}

// VoteCreateManyWithoutLinkInput input struct docs
type VoteCreateManyWithoutLinkInput struct {
	Create  *VoteCreateWithoutLinkInput `json:"create,omitempty"`
	Connect *VoteWhereUniqueInput       `json:"connect,omitempty"`
}

// VoteUpdateInput input struct docs
type VoteUpdateInput struct {
	Link    *LinkUpdateOneRequiredWithoutAllVotesInput `json:"link,omitempty"`
	VotedBy *UserUpdateOneRequiredWithoutVotesInput    `json:"votedBy,omitempty"`
}

// VoteCreateWithoutLinkInput input struct docs
type VoteCreateWithoutLinkInput struct {
	VotedBy *UserCreateOneWithoutVotesInput `json:"votedBy,omitempty"`
}

// UserUpdateInput input struct docs
type UserUpdateInput struct {
	Name     *string                             `json:"name,omitempty"`
	Email    *string                             `json:"email,omitempty"`
	Password *string                             `json:"password,omitempty"`
	Links    *LinkUpdateManyWithoutPostedByInput `json:"links,omitempty"`
	Votes    *VoteUpdateManyWithoutVotedByInput  `json:"votes,omitempty"`
}

// UserCreateOneWithoutVotesInput input struct docs
type UserCreateOneWithoutVotesInput struct {
	Create  *UserCreateWithoutVotesInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput        `json:"connect,omitempty"`
}

// UserCreateInput input struct docs
type UserCreateInput struct {
	Name     *string                             `json:"name,omitempty"`
	Email    *string                             `json:"email,omitempty"`
	Password *string                             `json:"password,omitempty"`
	Links    *LinkCreateManyWithoutPostedByInput `json:"links,omitempty"`
	Votes    *VoteCreateManyWithoutVotedByInput  `json:"votes,omitempty"`
}

// UserCreateWithoutVotesInput input struct docs
type UserCreateWithoutVotesInput struct {
	Name     *string                             `json:"name,omitempty"`
	Email    *string                             `json:"email,omitempty"`
	Password *string                             `json:"password,omitempty"`
	Links    *LinkCreateManyWithoutPostedByInput `json:"links,omitempty"`
}

// UserUpsertWithoutVotesInput input struct docs
type UserUpsertWithoutVotesInput struct {
	Update *UserUpdateWithoutVotesDataInput `json:"update,omitempty"`
	Create *UserCreateWithoutVotesInput     `json:"create,omitempty"`
}

// UserUpdateWithoutVotesDataInput input struct docs
type UserUpdateWithoutVotesDataInput struct {
	Name     *string                             `json:"name,omitempty"`
	Email    *string                             `json:"email,omitempty"`
	Password *string                             `json:"password,omitempty"`
	Links    *LinkUpdateManyWithoutPostedByInput `json:"links,omitempty"`
}

// VoteWhereUniqueInput input struct docs
type VoteWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

// LinkCreateWithoutPostedByInput input struct docs
type LinkCreateWithoutPostedByInput struct {
	Description *string                         `json:"description,omitempty"`
	Url         *string                         `json:"url,omitempty"`
	AllVotes    *VoteCreateManyWithoutLinkInput `json:"allVotes,omitempty"`
}

// LinkUpdateWithWhereUniqueWithoutPostedByInput input struct docs
type LinkUpdateWithWhereUniqueWithoutPostedByInput struct {
	Where *LinkWhereUniqueInput               `json:"where,omitempty"`
	Data  *LinkUpdateWithoutPostedByDataInput `json:"data,omitempty"`
}

// LinkUpdateInput input struct docs
type LinkUpdateInput struct {
	Description *string                         `json:"description,omitempty"`
	Url         *string                         `json:"url,omitempty"`
	PostedBy    *UserUpdateOneWithoutLinksInput `json:"postedBy,omitempty"`
	AllVotes    *VoteUpdateManyWithoutLinkInput `json:"allVotes,omitempty"`
}

// UserCreateOneWithoutLinksInput input struct docs
type UserCreateOneWithoutLinksInput struct {
	Create  *UserCreateWithoutLinksInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput        `json:"connect,omitempty"`
}

// UserWhereInput input struct docs
type UserWhereInput struct {
	ID                    *string         `json:"id,omitempty"`
	IDNot                 *string         `json:"id_not,omitempty"`
	IDIn                  *string         `json:"id_in,omitempty"`
	IDNotIn               *string         `json:"id_not_in,omitempty"`
	IDLt                  *string         `json:"id_lt,omitempty"`
	IDLte                 *string         `json:"id_lte,omitempty"`
	IDGt                  *string         `json:"id_gt,omitempty"`
	IDGte                 *string         `json:"id_gte,omitempty"`
	IDContains            *string         `json:"id_contains,omitempty"`
	IDNotContains         *string         `json:"id_not_contains,omitempty"`
	IDStartsWith          *string         `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string         `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string         `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string         `json:"id_not_ends_with,omitempty"`
	Name                  *string         `json:"name,omitempty"`
	NameNot               *string         `json:"name_not,omitempty"`
	NameIn                *string         `json:"name_in,omitempty"`
	NameNotIn             *string         `json:"name_not_in,omitempty"`
	NameLt                *string         `json:"name_lt,omitempty"`
	NameLte               *string         `json:"name_lte,omitempty"`
	NameGt                *string         `json:"name_gt,omitempty"`
	NameGte               *string         `json:"name_gte,omitempty"`
	NameContains          *string         `json:"name_contains,omitempty"`
	NameNotContains       *string         `json:"name_not_contains,omitempty"`
	NameStartsWith        *string         `json:"name_starts_with,omitempty"`
	NameNotStartsWith     *string         `json:"name_not_starts_with,omitempty"`
	NameEndsWith          *string         `json:"name_ends_with,omitempty"`
	NameNotEndsWith       *string         `json:"name_not_ends_with,omitempty"`
	Email                 *string         `json:"email,omitempty"`
	EmailNot              *string         `json:"email_not,omitempty"`
	EmailIn               *string         `json:"email_in,omitempty"`
	EmailNotIn            *string         `json:"email_not_in,omitempty"`
	EmailLt               *string         `json:"email_lt,omitempty"`
	EmailLte              *string         `json:"email_lte,omitempty"`
	EmailGt               *string         `json:"email_gt,omitempty"`
	EmailGte              *string         `json:"email_gte,omitempty"`
	EmailContains         *string         `json:"email_contains,omitempty"`
	EmailNotContains      *string         `json:"email_not_contains,omitempty"`
	EmailStartsWith       *string         `json:"email_starts_with,omitempty"`
	EmailNotStartsWith    *string         `json:"email_not_starts_with,omitempty"`
	EmailEndsWith         *string         `json:"email_ends_with,omitempty"`
	EmailNotEndsWith      *string         `json:"email_not_ends_with,omitempty"`
	Password              *string         `json:"password,omitempty"`
	PasswordNot           *string         `json:"password_not,omitempty"`
	PasswordIn            *string         `json:"password_in,omitempty"`
	PasswordNotIn         *string         `json:"password_not_in,omitempty"`
	PasswordLt            *string         `json:"password_lt,omitempty"`
	PasswordLte           *string         `json:"password_lte,omitempty"`
	PasswordGt            *string         `json:"password_gt,omitempty"`
	PasswordGte           *string         `json:"password_gte,omitempty"`
	PasswordContains      *string         `json:"password_contains,omitempty"`
	PasswordNotContains   *string         `json:"password_not_contains,omitempty"`
	PasswordStartsWith    *string         `json:"password_starts_with,omitempty"`
	PasswordNotStartsWith *string         `json:"password_not_starts_with,omitempty"`
	PasswordEndsWith      *string         `json:"password_ends_with,omitempty"`
	PasswordNotEndsWith   *string         `json:"password_not_ends_with,omitempty"`
	LinksEvery            *LinkWhereInput `json:"links_every,omitempty"`
	LinksSome             *LinkWhereInput `json:"links_some,omitempty"`
	LinksNone             *LinkWhereInput `json:"links_none,omitempty"`
	VotesEvery            *VoteWhereInput `json:"votes_every,omitempty"`
	VotesSome             *VoteWhereInput `json:"votes_some,omitempty"`
	VotesNone             *VoteWhereInput `json:"votes_none,omitempty"`
	And                   *UserWhereInput `json:"AND,omitempty"`
	Or                    *UserWhereInput `json:"OR,omitempty"`
	Not                   *UserWhereInput `json:"NOT,omitempty"`
}

// VoteCreateManyWithoutVotedByInput input struct docs
type VoteCreateManyWithoutVotedByInput struct {
	Create  *VoteCreateWithoutVotedByInput `json:"create,omitempty"`
	Connect *VoteWhereUniqueInput          `json:"connect,omitempty"`
}

// UserUpdateOneRequiredWithoutVotesInput input struct docs
type UserUpdateOneRequiredWithoutVotesInput struct {
	Create  *UserCreateWithoutVotesInput     `json:"create,omitempty"`
	Update  *UserUpdateWithoutVotesDataInput `json:"update,omitempty"`
	Upsert  *UserUpsertWithoutVotesInput     `json:"upsert,omitempty"`
	Connect *UserWhereUniqueInput            `json:"connect,omitempty"`
}

// LinkSubscriptionWhereInput input struct docs
type LinkSubscriptionWhereInput struct {
	MutationIn                 *MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                     `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery *string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  *string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *LinkWhereInput             `json:"node,omitempty"`
	And                        *LinkSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         *LinkSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        *LinkSubscriptionWhereInput `json:"NOT,omitempty"`
}

// VoteUpdateWithoutLinkDataInput input struct docs
type VoteUpdateWithoutLinkDataInput struct {
	VotedBy *UserUpdateOneRequiredWithoutVotesInput `json:"votedBy,omitempty"`
}

// UserWhereUniqueInput input struct docs
type UserWhereUniqueInput struct {
	ID    *string `json:"id,omitempty"`
	Email *string `json:"email,omitempty"`
}

// VoteUpdateWithWhereUniqueWithoutVotedByInput input struct docs
type VoteUpdateWithWhereUniqueWithoutVotedByInput struct {
	Where *VoteWhereUniqueInput              `json:"where,omitempty"`
	Data  *VoteUpdateWithoutVotedByDataInput `json:"data,omitempty"`
}

// LinkUpsertWithWhereUniqueWithoutPostedByInput input struct docs
type LinkUpsertWithWhereUniqueWithoutPostedByInput struct {
	Where  *LinkWhereUniqueInput               `json:"where,omitempty"`
	Update *LinkUpdateWithoutPostedByDataInput `json:"update,omitempty"`
	Create *LinkCreateWithoutPostedByInput     `json:"create,omitempty"`
}

// VoteUpdateWithoutVotedByDataInput input struct docs
type VoteUpdateWithoutVotedByDataInput struct {
	Link *LinkUpdateOneRequiredWithoutAllVotesInput `json:"link,omitempty"`
}

// LinkUpdateManyWithoutPostedByInput input struct docs
type LinkUpdateManyWithoutPostedByInput struct {
	Create     *LinkCreateWithoutPostedByInput                `json:"create,omitempty"`
	Delete     *LinkWhereUniqueInput                          `json:"delete,omitempty"`
	Connect    *LinkWhereUniqueInput                          `json:"connect,omitempty"`
	Disconnect *LinkWhereUniqueInput                          `json:"disconnect,omitempty"`
	Update     *LinkUpdateWithWhereUniqueWithoutPostedByInput `json:"update,omitempty"`
	Upsert     *LinkUpsertWithWhereUniqueWithoutPostedByInput `json:"upsert,omitempty"`
}

// LinkUpdateOneRequiredWithoutAllVotesInput input struct docs
type LinkUpdateOneRequiredWithoutAllVotesInput struct {
	Create  *LinkCreateWithoutAllVotesInput     `json:"create,omitempty"`
	Update  *LinkUpdateWithoutAllVotesDataInput `json:"update,omitempty"`
	Upsert  *LinkUpsertWithoutAllVotesInput     `json:"upsert,omitempty"`
	Connect *LinkWhereUniqueInput               `json:"connect,omitempty"`
}

// UserCreateWithoutLinksInput input struct docs
type UserCreateWithoutLinksInput struct {
	Name     *string                            `json:"name,omitempty"`
	Email    *string                            `json:"email,omitempty"`
	Password *string                            `json:"password,omitempty"`
	Votes    *VoteCreateManyWithoutVotedByInput `json:"votes,omitempty"`
}

// LinkUpdateWithoutAllVotesDataInput input struct docs
type LinkUpdateWithoutAllVotesDataInput struct {
	Description *string                         `json:"description,omitempty"`
	Url         *string                         `json:"url,omitempty"`
	PostedBy    *UserUpdateOneWithoutLinksInput `json:"postedBy,omitempty"`
}

// VoteCreateInput input struct docs
type VoteCreateInput struct {
	Link    *LinkCreateOneWithoutAllVotesInput `json:"link,omitempty"`
	VotedBy *UserCreateOneWithoutVotesInput    `json:"votedBy,omitempty"`
}

// VoteUpdateManyWithoutLinkInput input struct docs
type VoteUpdateManyWithoutLinkInput struct {
	Create     *VoteCreateWithoutLinkInput                `json:"create,omitempty"`
	Delete     *VoteWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    *VoteWhereUniqueInput                      `json:"connect,omitempty"`
	Disconnect *VoteWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     *VoteUpdateWithWhereUniqueWithoutLinkInput `json:"update,omitempty"`
	Upsert     *VoteUpsertWithWhereUniqueWithoutLinkInput `json:"upsert,omitempty"`
}

// UserUpsertWithoutLinksInput input struct docs
type UserUpsertWithoutLinksInput struct {
	Update *UserUpdateWithoutLinksDataInput `json:"update,omitempty"`
	Create *UserCreateWithoutLinksInput     `json:"create,omitempty"`
}

// VoteUpsertWithWhereUniqueWithoutVotedByInput input struct docs
type VoteUpsertWithWhereUniqueWithoutVotedByInput struct {
	Where  *VoteWhereUniqueInput              `json:"where,omitempty"`
	Update *VoteUpdateWithoutVotedByDataInput `json:"update,omitempty"`
	Create *VoteCreateWithoutVotedByInput     `json:"create,omitempty"`
}

// LinkUpsertWithoutAllVotesInput input struct docs
type LinkUpsertWithoutAllVotesInput struct {
	Update *LinkUpdateWithoutAllVotesDataInput `json:"update,omitempty"`
	Create *LinkCreateWithoutAllVotesInput     `json:"create,omitempty"`
}

// VoteUpsertWithWhereUniqueWithoutLinkInput input struct docs
type VoteUpsertWithWhereUniqueWithoutLinkInput struct {
	Where  *VoteWhereUniqueInput           `json:"where,omitempty"`
	Update *VoteUpdateWithoutLinkDataInput `json:"update,omitempty"`
	Create *VoteCreateWithoutLinkInput     `json:"create,omitempty"`
}

// VoteSubscriptionWhereInput input struct docs
type VoteSubscriptionWhereInput struct {
	MutationIn                 *MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                     `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery *string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  *string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *VoteWhereInput             `json:"node,omitempty"`
	And                        *VoteSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         *VoteSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        *VoteSubscriptionWhereInput `json:"NOT,omitempty"`
}

// LinkCreateInput input struct docs
type LinkCreateInput struct {
	Description *string                         `json:"description,omitempty"`
	Url         *string                         `json:"url,omitempty"`
	PostedBy    *UserCreateOneWithoutLinksInput `json:"postedBy,omitempty"`
	AllVotes    *VoteCreateManyWithoutLinkInput `json:"allVotes,omitempty"`
}

// LinkUpdateWithoutPostedByDataInput input struct docs
type LinkUpdateWithoutPostedByDataInput struct {
	Description *string                         `json:"description,omitempty"`
	Url         *string                         `json:"url,omitempty"`
	AllVotes    *VoteUpdateManyWithoutLinkInput `json:"allVotes,omitempty"`
}

// NodeExec docs
type NodeExec struct {
	client Client
	stack  []Instruction
}

// Node docs - generated with types in GraphQLInterfaceType
type Node interface {
	ID() string
}

// VotePreviousValuesExec docs
type VotePreviousValuesExec struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance VotePreviousValuesExec) Exec() (VotePreviousValues, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData VotePreviousValues
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// VotePreviousValuesExecArray docs
type VotePreviousValuesExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance VotePreviousValuesExecArray) Exec() ([]VotePreviousValues, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []VotePreviousValues
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// VotePreviousValues docs - generated with types
type VotePreviousValues struct {
	ID string `json:"id"`
}

// VoteExec docs
type VoteExec struct {
	client Client
	stack  []Instruction
}

// Link docs - executable for types
func (instance *VoteExec) Link() *LinkExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "link",
		Field: GraphQLField{
			Name:       "link",
			TypeName:   "Link",
			TypeFields: []string{"id", "createdAt", "description", "url"},
		},
		Operation: "",
		Args:      args,
	})
	return &LinkExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// VotedBy docs - executable for types
func (instance *VoteExec) VotedBy() *UserExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "votedBy",
		Field: GraphQLField{
			Name:       "votedBy",
			TypeName:   "User",
			TypeFields: []string{"id", "name", "email", "password"},
		},
		Operation: "",
		Args:      args,
	})
	return &UserExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance VoteExec) Exec() (Vote, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData Vote
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// VoteExecArray docs
type VoteExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance VoteExecArray) Exec() ([]Vote, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []Vote
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// Vote docs - generated with types
type Vote struct {
	ID string `json:"id"`
}

// LinkConnectionExec docs
type LinkConnectionExec struct {
	client Client
	stack  []Instruction
}

// PageInfo docs - executable for types
func (instance *LinkConnectionExec) PageInfo() *PageInfoExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "pageInfo",
		Field: GraphQLField{
			Name:       "pageInfo",
			TypeName:   "PageInfo",
			TypeFields: []string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"},
		},
		Operation: "",
		Args:      args,
	})
	return &PageInfoExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Edges docs - executable for types
func (instance *LinkConnectionExec) Edges() *LinkEdgeExecArray {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "edges",
		Field: GraphQLField{
			Name:       "edges",
			TypeName:   "LinkEdge",
			TypeFields: []string{"cursor"},
		},
		Operation: "",
		Args:      args,
	})
	return &LinkEdgeExecArray{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Aggregate docs - executable for types
func (instance *LinkConnectionExec) Aggregate() *AggregateLinkExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "aggregate",
		Field: GraphQLField{
			Name:       "aggregate",
			TypeName:   "AggregateLink",
			TypeFields: []string{"count"},
		},
		Operation: "",
		Args:      args,
	})
	return &AggregateLinkExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance LinkConnectionExec) Exec() (LinkConnection, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData LinkConnection
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// LinkConnectionExecArray docs
type LinkConnectionExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance LinkConnectionExecArray) Exec() ([]LinkConnection, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []LinkConnection
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// LinkConnection docs - generated with types
type LinkConnection struct {
}

// UserPreviousValuesExec docs
type UserPreviousValuesExec struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance UserPreviousValuesExec) Exec() (UserPreviousValues, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData UserPreviousValues
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// UserPreviousValuesExecArray docs
type UserPreviousValuesExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance UserPreviousValuesExecArray) Exec() ([]UserPreviousValues, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []UserPreviousValues
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// UserPreviousValues docs - generated with types
type UserPreviousValues struct {
	ID       string `json:"id"`
	Name     string `json:"name"`
	Email    string `json:"email"`
	Password string `json:"password"`
}

// AggregateLinkExec docs
type AggregateLinkExec struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance AggregateLinkExec) Exec() (AggregateLink, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData AggregateLink
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// AggregateLinkExecArray docs
type AggregateLinkExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance AggregateLinkExecArray) Exec() ([]AggregateLink, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []AggregateLink
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// AggregateLink docs - generated with types
type AggregateLink struct {
	Count int32 `json:"count"`
}

// UserExec docs
type UserExec struct {
	client Client
	stack  []Instruction
}

type LinksParamsExec struct {
	Where   *LinkWhereInput
	OrderBy *LinkOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

// Links docs - executable for types
func (instance *UserExec) Links(params *LinksParamsExec) *LinkExecArray {
	var args []GraphQLArg

	if params != nil {

		if params.Where != nil {
			args = append(args, GraphQLArg{
				Name:     "where",
				Key:      "where",
				TypeName: "LinkWhereInput",
				Value:    params.Where,
			})
		}

		if params.OrderBy != nil {
			args = append(args, GraphQLArg{
				Name:     "orderBy",
				Key:      "orderBy",
				TypeName: "LinkOrderByInput",
				Value:    params.OrderBy,
			})
		}

		if params.Skip != nil {
			args = append(args, GraphQLArg{
				Name:     "skip",
				Key:      "skip",
				TypeName: "int32",
				Value:    params.Skip,
			})
		}

		if params.After != nil {
			args = append(args, GraphQLArg{
				Name:     "after",
				Key:      "after",
				TypeName: "string",
				Value:    params.After,
			})
		}

		if params.Before != nil {
			args = append(args, GraphQLArg{
				Name:     "before",
				Key:      "before",
				TypeName: "string",
				Value:    params.Before,
			})
		}

		if params.First != nil {
			args = append(args, GraphQLArg{
				Name:     "first",
				Key:      "first",
				TypeName: "int32",
				Value:    params.First,
			})
		}

		if params.Last != nil {
			args = append(args, GraphQLArg{
				Name:     "last",
				Key:      "last",
				TypeName: "int32",
				Value:    params.Last,
			})
		}

	}

	instance.stack = append(instance.stack, Instruction{
		Name: "links",
		Field: GraphQLField{
			Name:       "links",
			TypeName:   "Link",
			TypeFields: []string{"id", "createdAt", "description", "url"},
		},
		Operation: "",
		Args:      args,
	})
	return &LinkExecArray{
		client: instance.client,
		stack:  instance.stack,
	}
}

type VotesParamsExec struct {
	Where   *VoteWhereInput
	OrderBy *VoteOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

// Votes docs - executable for types
func (instance *UserExec) Votes(params *VotesParamsExec) *VoteExecArray {
	var args []GraphQLArg

	if params != nil {

		if params.Where != nil {
			args = append(args, GraphQLArg{
				Name:     "where",
				Key:      "where",
				TypeName: "VoteWhereInput",
				Value:    params.Where,
			})
		}

		if params.OrderBy != nil {
			args = append(args, GraphQLArg{
				Name:     "orderBy",
				Key:      "orderBy",
				TypeName: "VoteOrderByInput",
				Value:    params.OrderBy,
			})
		}

		if params.Skip != nil {
			args = append(args, GraphQLArg{
				Name:     "skip",
				Key:      "skip",
				TypeName: "int32",
				Value:    params.Skip,
			})
		}

		if params.After != nil {
			args = append(args, GraphQLArg{
				Name:     "after",
				Key:      "after",
				TypeName: "string",
				Value:    params.After,
			})
		}

		if params.Before != nil {
			args = append(args, GraphQLArg{
				Name:     "before",
				Key:      "before",
				TypeName: "string",
				Value:    params.Before,
			})
		}

		if params.First != nil {
			args = append(args, GraphQLArg{
				Name:     "first",
				Key:      "first",
				TypeName: "int32",
				Value:    params.First,
			})
		}

		if params.Last != nil {
			args = append(args, GraphQLArg{
				Name:     "last",
				Key:      "last",
				TypeName: "int32",
				Value:    params.Last,
			})
		}

	}

	instance.stack = append(instance.stack, Instruction{
		Name: "votes",
		Field: GraphQLField{
			Name:       "votes",
			TypeName:   "Vote",
			TypeFields: []string{"id"},
		},
		Operation: "",
		Args:      args,
	})
	return &VoteExecArray{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance UserExec) Exec() (User, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData User
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// UserExecArray docs
type UserExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance UserExecArray) Exec() ([]User, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []User
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// User docs - generated with types
type User struct {
	ID       string `json:"id"`
	Name     string `json:"name"`
	Email    string `json:"email"`
	Password string `json:"password"`
}

// AggregateVoteExec docs
type AggregateVoteExec struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance AggregateVoteExec) Exec() (AggregateVote, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData AggregateVote
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// AggregateVoteExecArray docs
type AggregateVoteExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance AggregateVoteExecArray) Exec() ([]AggregateVote, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []AggregateVote
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// AggregateVote docs - generated with types
type AggregateVote struct {
	Count int32 `json:"count"`
}

// LinkEdgeExec docs
type LinkEdgeExec struct {
	client Client
	stack  []Instruction
}

// Node docs - executable for types
func (instance *LinkEdgeExec) Node() *LinkExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "node",
		Field: GraphQLField{
			Name:       "node",
			TypeName:   "Link",
			TypeFields: []string{"id", "createdAt", "description", "url"},
		},
		Operation: "",
		Args:      args,
	})
	return &LinkExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance LinkEdgeExec) Exec() (LinkEdge, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData LinkEdge
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// LinkEdgeExecArray docs
type LinkEdgeExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance LinkEdgeExecArray) Exec() ([]LinkEdge, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []LinkEdge
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// LinkEdge docs - generated with types
type LinkEdge struct {
	Cursor string `json:"cursor"`
}

// VoteConnectionExec docs
type VoteConnectionExec struct {
	client Client
	stack  []Instruction
}

// PageInfo docs - executable for types
func (instance *VoteConnectionExec) PageInfo() *PageInfoExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "pageInfo",
		Field: GraphQLField{
			Name:       "pageInfo",
			TypeName:   "PageInfo",
			TypeFields: []string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"},
		},
		Operation: "",
		Args:      args,
	})
	return &PageInfoExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Edges docs - executable for types
func (instance *VoteConnectionExec) Edges() *VoteEdgeExecArray {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "edges",
		Field: GraphQLField{
			Name:       "edges",
			TypeName:   "VoteEdge",
			TypeFields: []string{"cursor"},
		},
		Operation: "",
		Args:      args,
	})
	return &VoteEdgeExecArray{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Aggregate docs - executable for types
func (instance *VoteConnectionExec) Aggregate() *AggregateVoteExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "aggregate",
		Field: GraphQLField{
			Name:       "aggregate",
			TypeName:   "AggregateVote",
			TypeFields: []string{"count"},
		},
		Operation: "",
		Args:      args,
	})
	return &AggregateVoteExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance VoteConnectionExec) Exec() (VoteConnection, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData VoteConnection
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// VoteConnectionExecArray docs
type VoteConnectionExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance VoteConnectionExecArray) Exec() ([]VoteConnection, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []VoteConnection
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// VoteConnection docs - generated with types
type VoteConnection struct {
}

// UserSubscriptionPayloadExec docs
type UserSubscriptionPayloadExec struct {
	client Client
	stack  []Instruction
}

// Node docs - executable for types
func (instance *UserSubscriptionPayloadExec) Node() *UserExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "node",
		Field: GraphQLField{
			Name:       "node",
			TypeName:   "User",
			TypeFields: []string{"id", "name", "email", "password"},
		},
		Operation: "",
		Args:      args,
	})
	return &UserExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// PreviousValues docs - executable for types
func (instance *UserSubscriptionPayloadExec) PreviousValues() *UserPreviousValuesExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "previousValues",
		Field: GraphQLField{
			Name:       "previousValues",
			TypeName:   "UserPreviousValues",
			TypeFields: []string{"id", "name", "email", "password"},
		},
		Operation: "",
		Args:      args,
	})
	return &UserPreviousValuesExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance UserSubscriptionPayloadExec) Exec() (UserSubscriptionPayload, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData UserSubscriptionPayload
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// UserSubscriptionPayloadExecArray docs
type UserSubscriptionPayloadExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance UserSubscriptionPayloadExecArray) Exec() ([]UserSubscriptionPayload, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []UserSubscriptionPayload
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// UserSubscriptionPayload docs - generated with types
type UserSubscriptionPayload struct {
	UpdatedFields string `json:"updatedFields,omitempty"`
}

// UserEdgeExec docs
type UserEdgeExec struct {
	client Client
	stack  []Instruction
}

// Node docs - executable for types
func (instance *UserEdgeExec) Node() *UserExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "node",
		Field: GraphQLField{
			Name:       "node",
			TypeName:   "User",
			TypeFields: []string{"id", "name", "email", "password"},
		},
		Operation: "",
		Args:      args,
	})
	return &UserExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance UserEdgeExec) Exec() (UserEdge, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData UserEdge
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// UserEdgeExecArray docs
type UserEdgeExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance UserEdgeExecArray) Exec() ([]UserEdge, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []UserEdge
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// UserEdge docs - generated with types
type UserEdge struct {
	Cursor string `json:"cursor"`
}

// BatchPayloadExec docs
type BatchPayloadExec struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance BatchPayloadExec) Exec() (BatchPayload, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData BatchPayload
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// BatchPayloadExecArray docs
type BatchPayloadExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance BatchPayloadExecArray) Exec() ([]BatchPayload, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []BatchPayload
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// BatchPayload docs - generated with types
type BatchPayload struct {
	Count int64 `json:"count"`
}

// LinkPreviousValuesExec docs
type LinkPreviousValuesExec struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance LinkPreviousValuesExec) Exec() (LinkPreviousValues, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData LinkPreviousValues
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// LinkPreviousValuesExecArray docs
type LinkPreviousValuesExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance LinkPreviousValuesExecArray) Exec() ([]LinkPreviousValues, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []LinkPreviousValues
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// LinkPreviousValues docs - generated with types
type LinkPreviousValues struct {
	ID          string `json:"id"`
	CreatedAt   string `json:"createdAt"`
	Description string `json:"description"`
	Url         string `json:"url"`
}

// LinkSubscriptionPayloadExec docs
type LinkSubscriptionPayloadExec struct {
	client Client
	stack  []Instruction
}

// Node docs - executable for types
func (instance *LinkSubscriptionPayloadExec) Node() *LinkExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "node",
		Field: GraphQLField{
			Name:       "node",
			TypeName:   "Link",
			TypeFields: []string{"id", "createdAt", "description", "url"},
		},
		Operation: "",
		Args:      args,
	})
	return &LinkExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// PreviousValues docs - executable for types
func (instance *LinkSubscriptionPayloadExec) PreviousValues() *LinkPreviousValuesExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "previousValues",
		Field: GraphQLField{
			Name:       "previousValues",
			TypeName:   "LinkPreviousValues",
			TypeFields: []string{"id", "createdAt", "description", "url"},
		},
		Operation: "",
		Args:      args,
	})
	return &LinkPreviousValuesExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance LinkSubscriptionPayloadExec) Exec() (LinkSubscriptionPayload, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData LinkSubscriptionPayload
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// LinkSubscriptionPayloadExecArray docs
type LinkSubscriptionPayloadExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance LinkSubscriptionPayloadExecArray) Exec() ([]LinkSubscriptionPayload, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []LinkSubscriptionPayload
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// LinkSubscriptionPayload docs - generated with types
type LinkSubscriptionPayload struct {
	UpdatedFields string `json:"updatedFields,omitempty"`
}

// LinkExec docs
type LinkExec struct {
	client Client
	stack  []Instruction
}

// PostedBy docs - executable for types
func (instance *LinkExec) PostedBy() *UserExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "postedBy",
		Field: GraphQLField{
			Name:       "postedBy",
			TypeName:   "User",
			TypeFields: []string{"id", "name", "email", "password"},
		},
		Operation: "",
		Args:      args,
	})
	return &UserExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

type AllVotesParamsExec struct {
	Where   *VoteWhereInput
	OrderBy *VoteOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

// AllVotes docs - executable for types
func (instance *LinkExec) AllVotes(params *AllVotesParamsExec) *VoteExecArray {
	var args []GraphQLArg

	if params != nil {

		if params.Where != nil {
			args = append(args, GraphQLArg{
				Name:     "where",
				Key:      "where",
				TypeName: "VoteWhereInput",
				Value:    params.Where,
			})
		}

		if params.OrderBy != nil {
			args = append(args, GraphQLArg{
				Name:     "orderBy",
				Key:      "orderBy",
				TypeName: "VoteOrderByInput",
				Value:    params.OrderBy,
			})
		}

		if params.Skip != nil {
			args = append(args, GraphQLArg{
				Name:     "skip",
				Key:      "skip",
				TypeName: "int32",
				Value:    params.Skip,
			})
		}

		if params.After != nil {
			args = append(args, GraphQLArg{
				Name:     "after",
				Key:      "after",
				TypeName: "string",
				Value:    params.After,
			})
		}

		if params.Before != nil {
			args = append(args, GraphQLArg{
				Name:     "before",
				Key:      "before",
				TypeName: "string",
				Value:    params.Before,
			})
		}

		if params.First != nil {
			args = append(args, GraphQLArg{
				Name:     "first",
				Key:      "first",
				TypeName: "int32",
				Value:    params.First,
			})
		}

		if params.Last != nil {
			args = append(args, GraphQLArg{
				Name:     "last",
				Key:      "last",
				TypeName: "int32",
				Value:    params.Last,
			})
		}

	}

	instance.stack = append(instance.stack, Instruction{
		Name: "allVotes",
		Field: GraphQLField{
			Name:       "allVotes",
			TypeName:   "Vote",
			TypeFields: []string{"id"},
		},
		Operation: "",
		Args:      args,
	})
	return &VoteExecArray{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance LinkExec) Exec() (Link, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData Link
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// LinkExecArray docs
type LinkExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance LinkExecArray) Exec() ([]Link, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []Link
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// Link docs - generated with types
type Link struct {
	ID          string `json:"id"`
	CreatedAt   string `json:"createdAt"`
	Description string `json:"description"`
	Url         string `json:"url"`
}

// PageInfoExec docs
type PageInfoExec struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance PageInfoExec) Exec() (PageInfo, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData PageInfo
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// PageInfoExecArray docs
type PageInfoExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance PageInfoExecArray) Exec() ([]PageInfo, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []PageInfo
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// PageInfo docs - generated with types
type PageInfo struct {
	HasNextPage     bool   `json:"hasNextPage"`
	HasPreviousPage bool   `json:"hasPreviousPage"`
	StartCursor     string `json:"startCursor,omitempty"`
	EndCursor       string `json:"endCursor,omitempty"`
}

// VoteSubscriptionPayloadExec docs
type VoteSubscriptionPayloadExec struct {
	client Client
	stack  []Instruction
}

// Node docs - executable for types
func (instance *VoteSubscriptionPayloadExec) Node() *VoteExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "node",
		Field: GraphQLField{
			Name:       "node",
			TypeName:   "Vote",
			TypeFields: []string{"id"},
		},
		Operation: "",
		Args:      args,
	})
	return &VoteExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// PreviousValues docs - executable for types
func (instance *VoteSubscriptionPayloadExec) PreviousValues() *VotePreviousValuesExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "previousValues",
		Field: GraphQLField{
			Name:       "previousValues",
			TypeName:   "VotePreviousValues",
			TypeFields: []string{"id"},
		},
		Operation: "",
		Args:      args,
	})
	return &VotePreviousValuesExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance VoteSubscriptionPayloadExec) Exec() (VoteSubscriptionPayload, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData VoteSubscriptionPayload
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// VoteSubscriptionPayloadExecArray docs
type VoteSubscriptionPayloadExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance VoteSubscriptionPayloadExecArray) Exec() ([]VoteSubscriptionPayload, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []VoteSubscriptionPayload
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// VoteSubscriptionPayload docs - generated with types
type VoteSubscriptionPayload struct {
	UpdatedFields string `json:"updatedFields,omitempty"`
}

// UserConnectionExec docs
type UserConnectionExec struct {
	client Client
	stack  []Instruction
}

// PageInfo docs - executable for types
func (instance *UserConnectionExec) PageInfo() *PageInfoExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "pageInfo",
		Field: GraphQLField{
			Name:       "pageInfo",
			TypeName:   "PageInfo",
			TypeFields: []string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"},
		},
		Operation: "",
		Args:      args,
	})
	return &PageInfoExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Edges docs - executable for types
func (instance *UserConnectionExec) Edges() *UserEdgeExecArray {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "edges",
		Field: GraphQLField{
			Name:       "edges",
			TypeName:   "UserEdge",
			TypeFields: []string{"cursor"},
		},
		Operation: "",
		Args:      args,
	})
	return &UserEdgeExecArray{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Aggregate docs - executable for types
func (instance *UserConnectionExec) Aggregate() *AggregateUserExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "aggregate",
		Field: GraphQLField{
			Name:       "aggregate",
			TypeName:   "AggregateUser",
			TypeFields: []string{"count"},
		},
		Operation: "",
		Args:      args,
	})
	return &AggregateUserExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance UserConnectionExec) Exec() (UserConnection, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData UserConnection
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// UserConnectionExecArray docs
type UserConnectionExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance UserConnectionExecArray) Exec() ([]UserConnection, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []UserConnection
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// UserConnection docs - generated with types
type UserConnection struct {
}

// AggregateUserExec docs
type AggregateUserExec struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance AggregateUserExec) Exec() (AggregateUser, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData AggregateUser
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// AggregateUserExecArray docs
type AggregateUserExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance AggregateUserExecArray) Exec() ([]AggregateUser, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []AggregateUser
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// AggregateUser docs - generated with types
type AggregateUser struct {
	Count int32 `json:"count"`
}

// VoteEdgeExec docs
type VoteEdgeExec struct {
	client Client
	stack  []Instruction
}

// Node docs - executable for types
func (instance *VoteEdgeExec) Node() *VoteExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "node",
		Field: GraphQLField{
			Name:       "node",
			TypeName:   "Vote",
			TypeFields: []string{"id"},
		},
		Operation: "",
		Args:      args,
	})
	return &VoteExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance VoteEdgeExec) Exec() (VoteEdge, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData VoteEdge
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// VoteEdgeExecArray docs
type VoteEdgeExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance VoteEdgeExecArray) Exec() ([]VoteEdge, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []VoteEdge
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// VoteEdge docs - generated with types
type VoteEdge struct {
	Cursor string `json:"cursor"`
}

// GraphQL Send a GraphQL operation request
func (client Client) GraphQL(query string, variables map[string]interface{}) (map[string]interface{}, error) {
	// TODO: Add auth support

	req := graphql.NewRequest(query)
	gqlClient := graphql.NewClient(
		(map[bool]string{true: client.Endpoint, false: "http://localhost:4466"})[client.Endpoint != ""],
	)

	for key, value := range variables {
		req.Var(key, value)
	}

	ctx := context.Background()

	// var respData ResponseStruct
	var respData map[string]interface{}
	if err := gqlClient.Run(ctx, req, &respData); err != nil {
		if client.Debug {
			fmt.Println("GraphQL Response:", respData)
		}
		return nil, err
	}
	return respData, nil
}
